## 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:
```js
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
示例 2:
```js
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```
## 解题思路

使用动态规划解答。
使用动态规划的题目，首先我们要找到状态转移方程。
先从简单的情况考虑。
1. 如果只有一间房屋，则偷盗该房屋，可以偷窃得到最高金额。
2. 如果只有两间房屋，由于两间房屋相邻，不能同时偷窃，只能偷窃其中一间，因此选择其中金额高的房间进行偷窃
3. 如果房屋数量大于两间，对于第 i 间房屋，有两个选择
    - 偷窃第 i间房屋，那么就不能偷窃第 i - 1间房屋，偷窃的总金额为前 i - 2 间房屋的最高金额与第k间房屋的金额之和
    - 不偷窃第 i 间房屋，偷窃总金额为 前 i - 1间房屋的最高总金额

在两个选项中选择金额最大的选项。使用dp[i]表示前 i 间房屋能偷窃到的最高金额，那么就有如下的状态转移方程: $$ dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]) $$ 

边界条件为：
1. 只有一间房屋，则偷窃该房屋 : `dp[0]=nums[0]`
2. 只有两间房屋时，选择其中金额较高的房屋进行偷窃  `dp[1] = Math.max(nums[0], nums[1])`


```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    const len = nums.length;
    if(len === 0) {
        return 0;
    }
    if(len === 1) {
        return nums[0];
    }
    let dp = [];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);

    for(let i = 2; i < len; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[len - 1];
};
```
上述方法使用 dp 数组来存储结果。考虑到 dp 数组的第 i 项只与第 i−1 和第 i−2 项有关，因此可以使用滚动数组，每次只存储前两间房间的最高总金额。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    const len = nums.length;
    if(len === 0) {
        return 0;
    }
    if(len === 1) {
        return nums[0];
    }
    let prevMax = nums[0];
    let currentMax = Math.max(nums[0], nums[1]);
    for(let i = 2; i < len; i++) {
        const temp  = currentMax;
        currentMax = Math.max(currentMax, prevMax + nums[i]);
        prevMax = temp;
    }
    return currentMax;
};
```