


思路分析： 这道题得采用贪心策略，就是使序列尽可能的长。蛋式这种策略好像给人一种错误的感觉，

比如[1,2,3,3,4,5]，如果采用此策略，将会是[1,2,3,4,5]和剩余的[3]。其实这个策略并不是这么简单的，比如它扫描到’1’的时候，由于它的前一个元素’0’不存在以’0’结尾的连续子序列，所以它这是向后寻找两个元素，凑成子序列[1,2,3]（这时1，2，3各被消耗了一个）。接着我们就应该访问到’3’，我们又去查询以’2’结尾的有没有合法的连续序列，但是没有，所以它此时只能向后寻找两个元素，凑出连续子序列[3,4,5]（3，4，5个被消耗了一次），结束访问。


```js
如果输入[1,2,3,3,4,4,5,5]，刚开始访问'1'，建立[1,2,3]，
接着访问'3'，建立[3,4,5]
接着访问'4'，由于第一步建立了[1,2,3]以4 - 1结尾的连续子序列，所以它放入，得到[1,2,3,4]
接着访问'5'，由于第一步建立了[1,2,3,4]以5 - 1结尾的连续子序列，所以它放入，得到[1,2,3,4,5]
```

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
//具体思路看题解区
var isPossible = function(nums) {
    let counter = new Array(10000).fill(0);
    let end = new Array(10000).fill(0);

    //以上实现两个hash(网上实现hash太费劲了，取了个巧，浪费了点空间)

    //先把每种牌的总数记下
    nums.forEach((item) => {
        counter[item]++;
    });

    //以下采取贪心策略：
    for (let i = 0; i < nums.length; i++) {
        let item = nums[i];
        if (counter[item] === 0) {
            //这种牌没得了，直接下一个
            continue;
        }
        counter[item]--;

        if (end[item - 1] > 0) {
            //可以续上先续上
            end[item - 1]--;
            end[item]++;
        }

        //因为是升序排列，所以如果有[1,2,3,4,4,5，6]时
        //先是4接上[1,2,3],然后另外一个4连上后头的，组成[4,5,6]
        //关键在数组已经按升序排序
        else if (counter[item + 1] > 0 && counter[item + 2] > 0) {
            counter[item + 1]--;
            counter[item + 2]--;
            end[item + 2]++;
        } else {
            return false;
        }
    }
    return true;
};
```


## 

- [LeetCode 分割数组为连续子序列（贪心策略、hash表）](https://blog.csdn.net/qq_41855420/article/details/89378748)